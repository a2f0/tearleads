/**
 * MLS Worker - Web Worker for MLS (RFC 9420) operations
 *
 * This worker loads the OpenMLS WASM module and handles all MLS cryptographic
 * operations in a dedicated thread. Communication with the main thread uses
 * structured message passing.
 */

// Type definitions for the WASM module (generated by wasm-pack)
interface MlsWasmModule {
  default: () => Promise<void>;
  MlsClient: {
    new (userId: string): MlsClientInstance;
  };
}

interface MlsClientInstance {
  generateKeyPackages(count: number): unknown;
  createGroup(groupName: string): unknown;
  joinGroup(welcomeB64: string): unknown;
  addMembers(groupId: string, keyPackagesB64: string[]): unknown;
  encrypt(groupId: string, plaintext: string): unknown;
  decrypt(groupId: string, ciphertextB64: string): unknown;
  getEpoch(groupId: string): number;
  exportState(): unknown;
  free(): void;
}

// Result type from WASM
interface WasmResult<T> {
  ok: boolean;
  value?: T;
  error?: string;
}

// Worker request types
export type MlsWorkerRequest =
  | { type: 'init'; userId: string }
  | { type: 'generateKeyPackages'; count: number }
  | { type: 'createGroup'; groupName: string }
  | { type: 'joinGroup'; welcomeData: string }
  | { type: 'addMembers'; groupId: string; keyPackages: string[] }
  | { type: 'encrypt'; groupId: string; plaintext: string }
  | { type: 'decrypt'; groupId: string; ciphertext: string }
  | { type: 'getEpoch'; groupId: string }
  | { type: 'exportState' };

// Worker response types
export type MlsWorkerResponse =
  | { type: 'initialized'; success: true }
  | { type: 'keyPackages'; packages: Array<{ id: string; data: string }> }
  | { type: 'groupCreated'; groupId: string; mlsGroupId: string }
  | { type: 'groupJoined'; groupId: string; mlsGroupId: string }
  | {
      type: 'membersAdded';
      commit: string;
      welcomes: Array<{ keyPackageRef: string; welcome: string }>;
    }
  | { type: 'encrypted'; ciphertext: string; epoch: number }
  | { type: 'decrypted'; plaintext: string; senderIndex: number }
  | { type: 'epoch'; epoch: number }
  | { type: 'stateExported'; state: unknown }
  | { type: 'error'; message: string };

// Global state
let mlsModule: MlsWasmModule | null = null;
let mlsClient: MlsClientInstance | null = null;

/**
 * Load the MLS WASM module
 */
async function loadWasmModule(): Promise<MlsWasmModule> {
  if (mlsModule) {
    return mlsModule;
  }

  // Dynamic import of the WASM module
  // The module is served from /mls/ in production
  // Use indirect eval to bypass TypeScript module resolution
  const importModule = new Function('url', 'return import(url)');
  const module = (await importModule('/mls/mls_wasm.js')) as MlsWasmModule;
  await module.default();
  mlsModule = module;
  return module;
}

/**
 * Handle incoming messages from the main thread
 */
async function handleMessage(
  request: MlsWorkerRequest
): Promise<MlsWorkerResponse> {
  try {
    switch (request.type) {
      case 'init': {
        const module = await loadWasmModule();
        mlsClient = new module.MlsClient(request.userId);
        return { type: 'initialized', success: true };
      }

      case 'generateKeyPackages': {
        if (!mlsClient) {
          return { type: 'error', message: 'MLS client not initialized' };
        }
        const result = mlsClient.generateKeyPackages(
          request.count
        ) as WasmResult<Array<{ id: string; data: string }>>;
        if (!result.ok || !result.value) {
          return {
            type: 'error',
            message: result.error ?? 'Failed to generate KeyPackages'
          };
        }
        return { type: 'keyPackages', packages: result.value };
      }

      case 'createGroup': {
        if (!mlsClient) {
          return { type: 'error', message: 'MLS client not initialized' };
        }
        const result = mlsClient.createGroup(request.groupName) as WasmResult<{
          group_id: string;
          mls_group_id: string;
        }>;
        if (!result.ok || !result.value) {
          return {
            type: 'error',
            message: result.error ?? 'Failed to create group'
          };
        }
        return {
          type: 'groupCreated',
          groupId: result.value.group_id,
          mlsGroupId: result.value.mls_group_id
        };
      }

      case 'joinGroup': {
        if (!mlsClient) {
          return { type: 'error', message: 'MLS client not initialized' };
        }
        const result = mlsClient.joinGroup(
          request.welcomeData
        ) as WasmResult<{ group_id: string; mls_group_id: string }>;
        if (!result.ok || !result.value) {
          return {
            type: 'error',
            message: result.error ?? 'Failed to join group'
          };
        }
        return {
          type: 'groupJoined',
          groupId: result.value.group_id,
          mlsGroupId: result.value.mls_group_id
        };
      }

      case 'addMembers': {
        if (!mlsClient) {
          return { type: 'error', message: 'MLS client not initialized' };
        }
        const result = mlsClient.addMembers(
          request.groupId,
          request.keyPackages
        ) as WasmResult<{
          commit: string;
          welcomes: Array<{ key_package_ref: string; welcome: string }>;
        }>;
        if (!result.ok || !result.value) {
          return {
            type: 'error',
            message: result.error ?? 'Failed to add members'
          };
        }
        return {
          type: 'membersAdded',
          commit: result.value.commit,
          welcomes: result.value.welcomes.map((w) => ({
            keyPackageRef: w.key_package_ref,
            welcome: w.welcome
          }))
        };
      }

      case 'encrypt': {
        if (!mlsClient) {
          return { type: 'error', message: 'MLS client not initialized' };
        }
        const result = mlsClient.encrypt(
          request.groupId,
          request.plaintext
        ) as WasmResult<{ ciphertext: string; epoch: number }>;
        if (!result.ok || !result.value) {
          return {
            type: 'error',
            message: result.error ?? 'Failed to encrypt message'
          };
        }
        return {
          type: 'encrypted',
          ciphertext: result.value.ciphertext,
          epoch: result.value.epoch
        };
      }

      case 'decrypt': {
        if (!mlsClient) {
          return { type: 'error', message: 'MLS client not initialized' };
        }
        const result = mlsClient.decrypt(
          request.groupId,
          request.ciphertext
        ) as WasmResult<{ plaintext: string; sender_index: number }>;
        if (!result.ok || !result.value) {
          return {
            type: 'error',
            message: result.error ?? 'Failed to decrypt message'
          };
        }
        return {
          type: 'decrypted',
          plaintext: result.value.plaintext,
          senderIndex: result.value.sender_index
        };
      }

      case 'getEpoch': {
        if (!mlsClient) {
          return { type: 'error', message: 'MLS client not initialized' };
        }
        const epoch = mlsClient.getEpoch(request.groupId);
        return { type: 'epoch', epoch };
      }

      case 'exportState': {
        if (!mlsClient) {
          return { type: 'error', message: 'MLS client not initialized' };
        }
        const result = mlsClient.exportState() as WasmResult<unknown>;
        if (!result.ok || !result.value) {
          return {
            type: 'error',
            message: result.error ?? 'Failed to export state'
          };
        }
        return { type: 'stateExported', state: result.value };
      }

      default:
        return {
          type: 'error',
          message: `Unknown request type: ${(request as { type: string }).type}`
        };
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    return { type: 'error', message };
  }
}

// Set up message handler
self.onmessage = async (event: MessageEvent<MlsWorkerRequest>) => {
  const response = await handleMessage(event.data);
  self.postMessage(response);
};

// Export types for use in main thread
export type { MlsClientInstance };
