appId: com.tearleads.rapid
---
# Database Relaunch Test - Verifies database works after app restart
# This catches stale connection issues where previous connections weren't properly closed
# Uses evalScript for DOM interaction as Maestro's extendedWaitUntil doesn't work reliably with Capacitor WebViews

# First launch - set up database with clean state
- launchApp:
    clearState: true

- assertVisible: "Tearleads"

# Define reusable helper functions
- evalScript: |
    window.waitFor = async (predicate, errorMessage, timeout = 10000) => {
      const interval = 200;
      const maxTries = timeout / interval;
      for (let i = 0; i < maxTries; i++) {
        if (await predicate()) return 'ok';
        await new Promise(resolve => setTimeout(resolve, interval));
      }
      throw new Error(errorMessage);
    };
    window.waitForStatus = (status) => window.waitFor(
      () => document.querySelector('[data-testid="db-status"]')?.textContent === status,
      `Expected "${status}" status`
    );
    window.waitForResult = (status, textMatch) => window.waitFor(
      () => {
        const result = document.querySelector('[data-testid="db-test-result"]');
        if (!result) return false;
        const hasStatus = result.getAttribute('data-status') === status;
        const hasText = !textMatch || result.textContent.includes(textMatch);
        return hasStatus && hasText;
      },
      `Expected result status "${status}"${textMatch ? ` with "${textMatch}"` : ''}`
    );
    window.setPassword = (password) => {
      const input = document.querySelector('[data-testid="db-password-input"]');
      input.value = password;
      input.dispatchEvent(new Event('input', { bubbles: true }));
    };
    'helpers loaded';

# Navigate to debug page
- evalScript: document.querySelector('[data-testid="debug-link"]').click()

# Wait for Debug page to load
- evalScript: window.waitFor(() => document.querySelector('[data-testid="database-test"]'), 'Database Test component not found')

# Reset database to ensure clean state
- evalScript: document.querySelector('[data-testid="db-reset-button"]').click()

# Wait for reset to complete
- evalScript: window.waitForResult('success')

# Enter password
- evalScript: window.setPassword('relaunchtest123')

# Set up database
- evalScript: document.querySelector('[data-testid="db-setup-button"]').click()

# Wait for setup to complete
- evalScript: |
    window.waitFor(
      () => {
        const result = document.querySelector('[data-testid="db-test-result"]');
        if (result?.getAttribute('data-status') === 'error') {
          throw new Error('Setup failed: ' + result.textContent);
        }
        return result?.getAttribute('data-status') === 'success';
      },
      'Setup did not complete'
    )

# Write test data
- evalScript: document.querySelector('[data-testid="db-write-button"]').click()

# Wait for write to complete
- evalScript: |
    window.waitFor(
      () => {
        const result = document.querySelector('[data-testid="db-test-result"]');
        if (result?.getAttribute('data-status') === 'error') {
          throw new Error('Write failed: ' + result.textContent);
        }
        return result?.getAttribute('data-status') === 'success' && result.textContent.includes('Wrote test data:');
      },
      'Write did not complete'
    )

# Lock the database before relaunch (simulates normal app close state)
- evalScript: document.querySelector('[data-testid="db-lock-button"]').click()

# Wait for lock to complete
- evalScript: window.waitForStatus('Locked')

# Stop the app (this is the key test - simulates app being killed)
- stopApp

# Relaunch WITHOUT clearing state - this is where stale connection bugs manifest
- launchApp:
    clearState: false

- assertVisible: "Tearleads"

# Re-define helper functions (they were lost when app was killed)
- evalScript: |
    window.waitFor = async (predicate, errorMessage, timeout = 10000) => {
      const interval = 200;
      const maxTries = timeout / interval;
      for (let i = 0; i < maxTries; i++) {
        if (await predicate()) return 'ok';
        await new Promise(resolve => setTimeout(resolve, interval));
      }
      throw new Error(errorMessage);
    };
    window.waitForStatus = (status) => window.waitFor(
      () => document.querySelector('[data-testid="db-status"]')?.textContent === status,
      `Expected "${status}" status`
    );
    window.waitForResult = (status, textMatch) => window.waitFor(
      () => {
        const result = document.querySelector('[data-testid="db-test-result"]');
        if (!result) return false;
        const hasStatus = result.getAttribute('data-status') === status;
        const hasText = !textMatch || result.textContent.includes(textMatch);
        return hasStatus && hasText;
      },
      `Expected result status "${status}"${textMatch ? ` with "${textMatch}"` : ''}`
    );
    window.setPassword = (password) => {
      const input = document.querySelector('[data-testid="db-password-input"]');
      input.value = password;
      input.dispatchEvent(new Event('input', { bubbles: true }));
    };
    'helpers loaded';

# Navigate to debug page
- evalScript: document.querySelector('[data-testid="debug-link"]').click()

# Wait for Debug page to load
- evalScript: window.waitFor(() => document.querySelector('[data-testid="database-test"]'), 'Database Test component not found after relaunch')

# Verify database shows as Locked (state persisted)
- evalScript: window.waitForStatus('Locked')

# Enter password again
- evalScript: window.setPassword('relaunchtest123')

# Unlock the database - THIS IS THE CRITICAL TEST
# If there's a stale connection issue, unlocking will fail here
- evalScript: document.querySelector('[data-testid="db-unlock-button"]').click()

# Wait for unlock to complete
- evalScript: |
    window.waitFor(
      () => {
        const result = document.querySelector('[data-testid="db-test-result"]');
        const status = document.querySelector('[data-testid="db-status"]');
        if (result?.getAttribute('data-status') === 'error') {
          throw new Error('Unlock after relaunch failed (stale connection?): ' + result.textContent);
        }
        return status?.textContent === 'Unlocked';
      },
      'Unlock did not complete after relaunch'
    )

# Read data to verify it persisted across app restart
- evalScript: document.querySelector('[data-testid="db-read-button"]').click()

# Verify read succeeded
- evalScript: |
    window.waitFor(
      () => {
        const result = document.querySelector('[data-testid="db-test-result"]');
        if (result?.getAttribute('data-status') === 'error') {
          throw new Error('Read after relaunch failed: ' + result.textContent);
        }
        return result?.getAttribute('data-status') === 'success' && result.textContent.includes('Read test data:');
      },
      'Read did not complete after relaunch'
    )

# Verify data value exists (should be test-value-TIMESTAMP format)
- evalScript: |
    (async () => {
      const testData = document.querySelector('[data-testid="db-test-data"]');
      if (testData && /^test-value-\d+$/.test(testData.textContent)) {
        return 'ok';
      }
      throw new Error('Data did not persist after relaunch. Got: ' + (testData ? testData.textContent : 'null'));
    })()

# Clean up - reset database
- evalScript: document.querySelector('[data-testid="db-reset-button"]').click()

- evalScript: window.waitForStatus('Not Set Up')
