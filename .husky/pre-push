#!/usr/bin/env sh
set -eu

LOCK_DIR="${TMPDIR:-/tmp}/tearleads-pre-push.lock"

release_lock() {
  if [ -d "$LOCK_DIR" ] && [ -f "$LOCK_DIR/pid" ]; then
    lock_pid="$(cat "$LOCK_DIR/pid" 2>/dev/null || true)"
    if [ "$lock_pid" = "$$" ]; then
      rm -rf "$LOCK_DIR"
    fi
  fi
}

lock_owner_description() {
  owner_pid="$1"
  if [ -z "$owner_pid" ]; then
    printf '%s' "pid=unknown"
    return
  fi

  owner_line="$(ps -p "$owner_pid" -o etime= -o command= 2>/dev/null | sed -e 's/^[[:space:]]*//')"
  if [ -n "$owner_line" ]; then
    printf '%s' "pid=$owner_pid $owner_line"
    return
  fi

  printf '%s' "pid=$owner_pid (process info unavailable)"
}

acquire_lock() {
  wait_step_seconds=2
  wait_log_interval_seconds=30
  max_wait_seconds=$((45 * 60))
  waited_since_log=0
  total_waited=0
  while ! mkdir "$LOCK_DIR" 2>/dev/null; do
    lock_owner="pid=unknown (no pid file)"
    if [ -f "$LOCK_DIR/pid" ]; then
      lock_pid="$(cat "$LOCK_DIR/pid" 2>/dev/null || true)"
      if [ -n "$lock_pid" ] && ! kill -0 "$lock_pid" 2>/dev/null; then
        stale_lock_dir="$LOCK_DIR.stale.$$"
        if mv "$LOCK_DIR" "$stale_lock_dir" 2>/dev/null; then
          rm -rf "$stale_lock_dir"
          continue
        fi
      fi
      lock_owner="$(lock_owner_description "$lock_pid")"
    fi

    if [ "$total_waited" -ge "$max_wait_seconds" ]; then
      echo "[pre-push] FAIL  timed out waiting for lock after ${total_waited}s (${lock_owner})" >&2
      exit 1
    fi

    remaining_wait=$((max_wait_seconds - total_waited))
    if [ "$waited_since_log" -eq 0 ]; then
      echo "[pre-push] WAIT  another pre-push is active; waiting (${lock_owner}, timeout in ${remaining_wait}s)..." >&2
    elif [ "$waited_since_log" -ge "$wait_log_interval_seconds" ]; then
      echo "[pre-push] WAIT  still waiting for lock (${total_waited}s elapsed, ${lock_owner}, timeout in ${remaining_wait}s)" >&2
      waited_since_log=0
    fi
    sleep "$wait_step_seconds"
    waited_since_log=$((waited_since_log + wait_step_seconds))
    total_waited=$((total_waited + wait_step_seconds))
  done
  printf '%s\n' "$$" > "$LOCK_DIR/pid"
}

trap 'release_lock' EXIT INT TERM HUP
acquire_lock

run_step() (
  label="$1"
  shift

  start=$(date +%s)
  echo "[pre-push] START ${label}" >&2

  set +e
  "$@"
  status=$?
  set -e

  end=$(date +%s)
  elapsed=$((end - start))

  if [ "$status" -ne 0 ]; then
    echo "[pre-push] FAIL  ${label} (${elapsed}s, exit ${status})" >&2
    exit "$status"
  fi

  echo "[pre-push] OK    ${label} (${elapsed}s)" >&2
)

run_step "checkNodeVersion" ./scripts/checks/checkNodeVersion.sh
run_step "checkFileLimits" ./scripts/checks/checkFileLimits.sh --from-upstream
run_step "checkSentinelMarkdownLinks" ./scripts/checks/checkSentinelMarkdownLinks.sh --all
run_step "checkBinaryFiles" ./scripts/checks/checkBinaryFiles.sh --from-upstream
run_step "checkJs" ./scripts/checks/checkJs.sh --from-upstream
run_step "checkFileNames" ./scripts/checks/checkFileNames.sh --from-upstream
run_step "checkClientBoundary" ./scripts/checks/checkClientBoundary.sh --from-upstream
run_step "checkApiBoundary" ./scripts/checks/checkApiBoundary.sh --from-upstream
run_step "checkPreenEcosystem" ./scripts/checks/preen/checkPreenEcosystem.ts --strict
run_step "checkCircularImports" ./scripts/checks/checkCircularImports.ts
run_step "checkTailwindSources" ./scripts/checks/checkTailwindSources.ts
run_step "checkGitHubActions" ./scripts/checks/checkGithubActions.sh --from-upstream
run_step "checkTerraform" ./scripts/checks/checkTerraform.sh
run_step "typecheckSolutionBuild" pnpm exec tsc -b
run_step "enforceTypeScriptIncrementalBuilds" pnpm enforceTypeScriptIncrementalBuilds
run_step "runImpactedQuality" pnpm exec tsx scripts/ciImpact/runImpactedQuality.ts --base origin/main --head HEAD
# Run impacted package coverage tests with conservative full-run fallback.
run_step "runImpactedTests" pnpm exec tsx scripts/ciImpact/runImpactedTests.ts --base origin/main --head HEAD
