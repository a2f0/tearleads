diff --git a/ios/Sources/FilesystemPlugin/FilesystemOperationExecutor.swift b/ios/Sources/FilesystemPlugin/FilesystemOperationExecutor.swift
index c5eea30f0d6a0773ef12037ff3f01d6de79dc093..35610d3e094555acce11a17659e67c93e0ba82b4 100644
--- a/ios/Sources/FilesystemPlugin/FilesystemOperationExecutor.swift
+++ b/ios/Sources/FilesystemPlugin/FilesystemOperationExecutor.swift
@@ -17,8 +17,8 @@ class FilesystemOperationExecutor {
 
             switch operation {
             case .readFile(let url, let encoding, let offset, let length):
-                let data = try service.readEntireFile(atURL: url, withEncoding: encoding, andOffset: offset, andLength: length).textValue
-                resultData = [Constants.ResultDataKey.data: data]
+                let data = try readFileWithOffsets(using: service, url: url, encoding: encoding, offset: offset, length: length)
+                resultData = [Constants.ResultDataKey.data: data.textValue]
             case .readFileInChunks(let url, let encoding, let chunkSize, let offset, let length):
                 try processFileInChunks(at: url, withEncoding: encoding, chunkSize: chunkSize, offset: offset, length: length, for: operation, call)
                 return
@@ -58,18 +58,23 @@ class FilesystemOperationExecutor {
 private extension FilesystemOperationExecutor {
     func processFileInChunks(at url: URL, withEncoding encoding: IONFILEEncoding, chunkSize: Int, offset: Int, length: Int, for operation: FilesystemOperation, _ call: CAPPluginCall) throws {
         let chunkSizeToUse = chunkSizeToUse(basedOn: chunkSize, and: encoding)
-        try service.readFileInChunks(atURL: url, withEncoding: encoding, andChunkSize: chunkSizeToUse, andOffset: offset, andLength: length)
-            .sink(receiveCompletion: { completion in
-                switch completion {
-                case .finished:
-                    call.handleSuccess([Constants.ResultDataKey.data: Constants.ConfigurationValue.endOfFile])
-                case .failure(let error):
-                    call.handleError(self.mapError(error, for: operation))
-                }
-            }, receiveValue: {
-                call.handleSuccess([Constants.ResultDataKey.data: $0.textValue], true)
-            })
-            .store(in: &cancellables)
+        if offset == 0 && length < 0 {
+            try service.readFileInChunks(atURL: url, withEncoding: encoding, andChunkSize: chunkSizeToUse)
+                .sink(receiveCompletion: { completion in
+                    switch completion {
+                    case .finished:
+                        call.handleSuccess([Constants.ResultDataKey.data: Constants.ConfigurationValue.endOfFile])
+                    case .failure(let error):
+                        call.handleError(self.mapError(error, for: operation))
+                    }
+                }, receiveValue: {
+                    call.handleSuccess([Constants.ResultDataKey.data: $0.textValue], true)
+                })
+                .store(in: &cancellables)
+            return
+        }
+
+        try processFileInChunksManually(at: url, withEncoding: encoding, chunkSize: chunkSizeToUse, offset: offset, length: length, for: operation, call)
     }
 
     private func chunkSizeToUse(basedOn chunkSize: Int, and encoding: IONFILEEncoding) -> Int {
@@ -78,6 +83,91 @@ private extension FilesystemOperationExecutor {
         encoding == .byteBuffer ? chunkSize - chunkSize % 3 + 3 : chunkSize
     }
 
+    private func readFileWithOffsets(using service: FileService, url: URL, encoding: IONFILEEncoding, offset: Int, length: Int) throws -> IONFILEEncodingValueMapper {
+        let mapper = try service.readEntireFile(atURL: url, withEncoding: encoding)
+        guard offset != 0 || length >= 0 else { return mapper }
+        return sliceEncodingValue(mapper, encoding: encoding, offset: offset, length: length)
+    }
+
+    private func processFileInChunksManually(at url: URL, withEncoding encoding: IONFILEEncoding, chunkSize: Int, offset: Int, length: Int, for operation: FilesystemOperation, _ call: CAPPluginCall) throws {
+        let mapper = try readFileWithOffsets(using: service, url: url, encoding: encoding, offset: offset, length: length)
+        switch mapper {
+        case .byteBuffer(let data):
+            let chunks = chunkData(data, chunkSize: chunkSize)
+            for chunk in chunks {
+                call.handleSuccess([Constants.ResultDataKey.data: chunk.base64EncodedString()], true)
+            }
+        case .string(_, let text):
+            let chunks = chunkString(text, chunkSize: chunkSize)
+            for chunk in chunks {
+                call.handleSuccess([Constants.ResultDataKey.data: chunk], true)
+            }
+        @unknown default:
+            break
+        }
+
+        call.handleSuccess([Constants.ResultDataKey.data: Constants.ConfigurationValue.endOfFile])
+    }
+
+    private func sliceEncodingValue(_ mapper: IONFILEEncodingValueMapper, encoding: IONFILEEncoding, offset: Int, length: Int) -> IONFILEEncodingValueMapper {
+        let safeOffset = max(0, offset)
+        let safeLength = length < 0 ? Int.max : max(0, length)
+
+        switch (mapper, encoding) {
+        case (.byteBuffer(let data), .byteBuffer):
+            let sliced = sliceData(data, offset: safeOffset, length: safeLength)
+            return .byteBuffer(value: sliced)
+        case (.string(let encodingType, let text), .string(let encodingTypeFromCall)):
+            let resolvedEncoding = encodingTypeFromCall
+            let stringEncoding = resolvedEncoding.foundationEncoding
+            let data = text.data(using: stringEncoding) ?? Data()
+            let sliced = sliceData(data, offset: safeOffset, length: safeLength)
+            let slicedText = String(data: sliced, encoding: stringEncoding) ?? ""
+            return .string(encoding: encodingType, value: slicedText)
+        case (.string(let encodingType, let text), _):
+            let stringEncoding = encodingType.foundationEncoding
+            let data = text.data(using: stringEncoding) ?? Data()
+            let sliced = sliceData(data, offset: safeOffset, length: safeLength)
+            let slicedText = String(data: sliced, encoding: stringEncoding) ?? ""
+            return .string(encoding: encodingType, value: slicedText)
+        case (.byteBuffer(let data), _):
+            let sliced = sliceData(data, offset: safeOffset, length: safeLength)
+            return .byteBuffer(value: sliced)
+        @unknown default:
+            return mapper
+        }
+    }
+
+    private func sliceData(_ data: Data, offset: Int, length: Int) -> Data {
+        guard offset < data.count else { return Data() }
+        let end = length == Int.max ? data.count : min(data.count, offset + length)
+        return data.subdata(in: offset..<end)
+    }
+
+    private func chunkData(_ data: Data, chunkSize: Int) -> [Data] {
+        guard chunkSize > 0 else { return [] }
+        var chunks: [Data] = []
+        var index = 0
+        while index < data.count {
+            let end = min(data.count, index + chunkSize)
+            chunks.append(data.subdata(in: index..<end))
+            index = end
+        }
+        return chunks
+    }
+
+    private func chunkString(_ text: String, chunkSize: Int) -> [String] {
+        guard chunkSize > 0 else { return [] }
+        var chunks: [String] = []
+        var currentIndex = text.startIndex
+        while currentIndex < text.endIndex {
+            let endIndex = text.index(currentIndex, offsetBy: chunkSize, limitedBy: text.endIndex) ?? text.endIndex
+            chunks.append(String(text[currentIndex..<endIndex]))
+            currentIndex = endIndex
+        }
+        return chunks
+    }
+
     func mapError(_ error: Error, for operation: FilesystemOperation) -> FilesystemError {
         var path = ""
         var method: IONFileMethod = IONFileMethod.getUri
@@ -114,3 +204,18 @@ private extension FilesystemOperationExecutor {
         return attributes.toJSResult(with: url)
     }
 }
+
+private extension IONFILEStringEncoding {
+    var foundationEncoding: String.Encoding {
+        switch self {
+        case .ascii:
+            return .ascii
+        case .utf16:
+            return .utf16
+        case .utf8:
+            return .utf8
+        @unknown default:
+            return .utf8
+        }
+    }
+}
